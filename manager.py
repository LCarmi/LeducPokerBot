from game import *
from orderFile import *


class Manager:

    # Construct the Manager given the file path
    def __init__(self, file_path: str):

        node_lines, infoset_lines = text_order_by_history_length(file_path)
        self.originalGame = Game()
        self.originalGame.parse_game(node_lines, infoset_lines)
        self.abstractedGame = Game()
        self.abstractedGame.parse_game(node_lines, infoset_lines)
        self.information_set_mapping = {}

    def create_abstraction(self):
        self.information_set_mapping = self.abstractedGame.abstract_yourself()

    def map_strategies(self):
        for key in self.information_set_mapping:
            infoset_to_copy = self.information_set_mapping.get(key)
            infoset_to_update = self.originalGame.get_infoset_from_name(key)
            infoset_to_update.update_actions(infoset_to_copy)


    def write_result(self) -> str:
        infosets = self.originalGame.information_sets
        result = ""
        for infoset in infosets:
            result = result + str(infoset) + '\n'

        return result

    def create_virtual_game(self, game:Game, p:int, depth: int) -> Game:
        res = game.find_nodes_at_depth_with_reach_probability(p,depth)
        actions = [str(i) for i in range(len(res))]
        probabilities = []
        children = []
        for node,probability in res:
            children.append(node)
            probabilities.append(probability)
        new_root = ChanceNode("Virtual_root", actions, probabilities, children)
        ret = Game()
        ret.root_node = new_root
        ret.information_sets = game.information_sets
        ret.history_dictionary = game.history_dictionary
        return ret



    # def create_limited_depth_game(self, p,d):
    #     find_roots(self.originalGame.root_node, p ,d, 0, 1)
    #     for each found node, create subgame
    #     # create new root node, using subgames generated by found child and probabilities
    #
    # def find_roots(self, node:Node, p ,d, cur_depth, cur_prob) -> [(Node, double)]:
    #
    #     if cur_depth<d:
    #         # compute probabilities of reaching node
    #         for c in node.children:
    #             limit_tree(c, p, d, cur_depth+1, cur_prob * #probability of choosing child based on strategy/chance HINT: use infosets)
    #
    #
    # def create_subgame(self, node:Node, p): # used on each node at d level
    #         for each child in node.children:
    #             new_node = remove_player(child, p)
    #
    #         substitute new_child in children

def mini_refinement(player, depth):
    n_refinements = 8
    virtual_game = manager.create_virtual_game(manager.originalGame, player, depth)

    if virtual_game.root_node.children:
        for i in range(n_refinements):
            virtual_game.compute_masks()
            virtual_game.mask_yourself()

            if virtual_game1.root_node.children:
                virtual_game.solve_subgame(player)

            virtual_game.restore_masks()
            virtual_game.adversary_response()

        virtual_game.update_infoset_from_subgame()

if __name__ == '__main__':

    file_path = "./Examples/input - kuhn.txt"
    manager = Manager(file_path)
    print("Game loaded!")

    manager.create_abstraction()
    print("Abstraction ended!")

    manager.abstractedGame.find_optimal_strategy()
    #manager.originalGame.find_optimal_strategy()
    print("Blue print strategy done in abstract game!")

    manager.map_strategies()
    print("Blue print mapped on the real game")

    print(manager.write_result())
    #res = manager.write_result()
    print("Refine strategy start")
    player = 1
    other_player = 2
    #Initialize the final strategy
    for infoset in manager.originalGame.information_sets:
        infoset.final_strategy=infoset.get_average_strategy()
    #Do the subgame for each level
    depth=1
    virtual_game1 = manager.create_virtual_game(manager.originalGame, player, depth)
    virtual_game2 = manager.create_virtual_game(manager.originalGame, other_player, depth)
    while virtual_game1.root_node.children != [] or virtual_game2.root_node.children != []:
        if virtual_game1.root_node.children:
            virtual_game1.solve_subgame(player)

        if virtual_game2.root_node.children:
            virtual_game2.solve_subgame(other_player)

        if virtual_game1.root_node.children:
            virtual_game1.update_infoset_from_subgame()

        if virtual_game2.root_node.children:
            virtual_game2.update_infoset_from_subgame()

        print("Refined level: " + str(depth))

        depth += 1
        virtual_game1 = manager.create_virtual_game(manager.originalGame, player, depth)
        virtual_game2 = manager.create_virtual_game(manager.originalGame, other_player, depth)

    print("Refine strategy done")
    print(manager.write_result())
    print("Expected Value: {}".format(manager.originalGame.root_node.expected_value(manager.originalGame.history_dictionary)))
    #print(res)
    # file_path_output = "./Examples/output.txt"
    # f = open(file_path_output, "w+")
    # f.write(out)
    # f.close()
    # print("Write finished")



