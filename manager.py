from game import *
from orderFile import *
from informationSet import *
import time


class Manager:

    # Construct the Manager given the file path
    def __init__(self, file_path: str):

        node_lines, infoset_lines = text_order_by_history_length(file_path)
        self.originalGame = Game()
        self.originalGame.parse_game(node_lines, infoset_lines)
        self.abstractedGame = Game()
        self.abstractedGame.parse_game(node_lines, infoset_lines)
        self.information_set_mapping = {}

    def create_abstraction(self):
        self.information_set_mapping = self.abstractedGame.abstract_yourself()

    def map_strategies(self):
        for key in self.information_set_mapping:
            infoset_to_copy = self.information_set_mapping.get(key)
            infoset_to_update = self.originalGame.get_infoset_from_name(key)
            infoset_to_update.update_actions(infoset_to_copy)

    def write_result(self) -> str:
        infosets = self.originalGame.information_sets
        result = ""
        for infoset in infosets:
            result = result + str(infoset) + '\n'

        return result

    def __create_virtual_game(self, game:Game, p:int, depth: int) -> Game:
        res = game.find_nodes_at_depth_with_reach_probability(p,depth)
        actions = [str(i) for i in range(len(res))]
        probabilities = []
        children = []
        for node,probability in res:
            children.append(node)
            probabilities.append(probability)
        new_root = ChanceNode("Virtual_root", actions, probabilities, children)
        ret = Game()
        ret.root_node = new_root
        ret.information_sets = game.information_sets
        ret.history_dictionary = game.history_dictionary
        return ret



    # def create_limited_depth_game(self, p,d):
    #     find_roots(self.originalGame.root_node, p ,d, 0, 1)
    #     for each found node, create subgame
    #     # create new root node, using subgames generated by found child and probabilities
    #
    # def find_roots(self, node:Node, p ,d, cur_depth, cur_prob) -> [(Node, double)]:
    #
    #     if cur_depth<d:
    #         # compute probabilities of reaching node
    #         for c in node.children:
    #             limit_tree(c, p, d, cur_depth+1, cur_prob * #probability of choosing child based on strategy/chance HINT: use infosets)
    #
    #
    # def create_subgame(self, node:Node, p): # used on each node at d level
    #         for each child in node.children:
    #             new_node = remove_player(child, p)
    #
    #         substitute new_child in children

if __name__ == '__main__':

    file_path = "./Examples/input - leduc3.txt"
    manager = Manager(file_path)

    print("Game loaded!")
    manager.create_abstraction()
    print("Abstraction ended!")
    #manager.abstractedGame.find_optimal_strategy()
    manager.originalGame.find_optimal_strategy()
    print("Optimum strategy done!")
    #manager.map_strategies()
    #res = manager.write_result()
    #print(res)
    # file_path_output = "./Examples/output.txt"
    # f = open(file_path_output, "w+")
    # f.write(out)
    # f.close()
    # print("Write finished")



